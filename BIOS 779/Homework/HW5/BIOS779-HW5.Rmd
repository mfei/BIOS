---
title: "BIOS779-HW5"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

---
title: 'PLUTO: Power Prior Example'
author: "Ethan Alt"
date: "01/12/2023"
output: 
  html_document:
    theme: united
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
register_knitr_engine(override = FALSE)
library(magrittr)
library(ISwR)
library(rstan)
library("readxl")
library(posterior)
library(bayesplot)
library(tidyverse)
library(ggthemes)
library(kableExtra)
library(broom)  # tidy regression output
library(mosaic)  # standardizing variables
```


### Data

```{R}
setwd("C:/Users/bltmp/Documents/BIOS779/HW5")

liver = read_excel("bios779-liverdata.xlsx")

#liver$fetop <- as.numeric(as.factor(liver$fetop))
#liver$hepB <- as.numeric(as.factor(liver$hepB))

liver$y <- as.numeric(liver$y)
liver$y0 <- 1 

##Standardize
liver_standardized <- 
  liver %>% 
  mutate(bmi_s = scale(BMI))%>% 
  mutate(age_s = scale(age))%>% 
  mutate(indx_s = scale(indx))%>% 
  mutate(fetop_s = scale(fetop))%>% 
  mutate(hepB_s = scale(hepB))%>% 
  mutate(jaund_s = scale(jaund))

livers <- 
  liver_standardized %>% select('y','bmi_s','age_s','indx_s','fetop_s','hepB_s','jaund_s' )
liver_hist <- 
  liver_standardized %>% select('y0','bmi_s','age_s','indx_s','fetop_s','hepB_s','jaund_s' )
colnames(liver_hist)[1] <- 'y'
liver_hist
```

### Stan 

Below, we implement the Stan code for the power prior.
```{cmdstan, output.var="ci_model", message=FALSE}

functions {
  real poisson_glm_conjugate_lpdf(vector beta, vector mu0, matrix X, real lambda) {
    int N = rows(X);
    vector[N] eta = X * beta;
    return lambda * sum( mu0 .* eta -  exp(eta) );
  }
}

data {
  // Number of observations (an integer)
  int<lower=0> N;                 
  // Number of beta parameters
  int<lower=0> p;                    

  /* Design Matrix */
  matrix[N,p] X; 
 
  // Count outcome
  array[N] int <lower=0,upper=1> y;
  
  // conjugate prior- discounting parameter
  real<lower=0,upper=1> lambda;         

  // MLE of historical data set
  vector[p] betahat0;
  
}
parameters {
  // Define parameters to estimate
  vector[p] beta; 
}
transformed parameters {
  // 
  vector[N] mu0 = exp(X * betahat0);

}
model {
  // conjugate prior - beta
  
  target += poisson_glm_conjugate_lpdf(beta | mu0, X, lambda);
  
  // log likelihood
 
  target += poisson_log_glm_lpmf( y | X, beta[1], beta[2:p]);
  
}


```




### Analysis in R
#### Creation of the Stan data
Now, we must tell `stan` what the variables named in the `data{}` block are.
This is done by creating a named list as follows.
```{r standata}

lambda <- 1

formula <- y ~ bmi_s + age_s + indx_s + fetop_s + hepB_s + jaund_s

hist.fit <- glm(formula, family = 'poisson', data = liver_hist)
hist.fit %>% tidy() %>% kable(digits = 3) %>% kable_classic(full_width = FALSE)

standata <- list(
  'y' = livers[, all.vars(formula)[1]]
  , 'X' = model.matrix(formula, livers)
  , 'betahat0' = coef(hist.fit)
  , 'lambda'   = lambda
)
standata$N  <- nrow(standata$X)
standata$p  <- ncol(standata$X)

```



## Conduct MCMC sampling

```{r mcmc, message = FALSE, warning = FALSE}
ci_smpl <- 
  ci_model$sample(
  data = standata, iter_warmup = 1000, iter_sampling = 2500, parallel_chains = 4, chains = 4, refresh = 0
)
```

To access the samples, we use the `draws` method, which in turn uses the
convenient `posterior` package. We will obtain the draws via a special `data.frame`
called a `draws_df`.
```{r}
pp_mcmc <- pp_smpl$draws(format = 'draws_df')
pp_mcmc %>% summarize_draws()
```

By default, the `summarize_draws()` method gives $90\%$ credible intervals. To
obtain a 95\% CI, we can do the following:
```{r}
pp_mcmc %>% summarize_draws(quantile2, .args = list(probs = c(0.025, 0.975)))
```

More generally, we can summarize different posterior quantities
```{r}
pp_mcmc %>% summarize_draws(
  'mean', 'sd', ~quantile(.x, probs = c(0.025, 0.975)), 'pgt0' = ~mean(.x > 0), 'pgt1' = ~mean(.x > 1)
)
```


In this case, the trial would be unsuccessful. Let's see what happens when
we change $a_{01} = a_{02} = 0.3$
```{r}
standata$a0 <- rep(0.2, 2)
pp_smpl2 <- pp_model$sample(
  data = standata, iter_warmup = 2000, iter_sampling = 2500
  , chains = 4, parallel_chains = 4, refresh = 0
)
pp_mcmc2 <- pp_smpl2$draws(format = 'draws_df')
pp_mcmc2 %>% summarize_draws(
  'mean', 'sd', ~quantile(.x, probs = c(0.025, 0.975)), 'pgt0' = ~mean(.x > 0), 'pgt1' = ~mean(.x > 1)
)
```


### Plots
The `bayesplot` package provides nice diagnostic plots. 


#### Trace plots

Trace plots show how the MCMC converges. Ideally, we want to see lines randomly
fluctuating.

```{r}
pp_mcmc2 %>% mcmc_trace()
```

#### Autocorrelation plots

Autocorrelation can sometimes be problematic as it can indicate that the
chain is "stuck". 

```{r}
pp_mcmc2 %>% mcmc_acf()
```

### Posterior plots

Oftentimes, it's useful to plot the posterior distribution of each parameter

```{r}
## Posterior histogram
pp_mcmc2 %>% mcmc_hist()
```



#### Comparing with reference prior

We set $\theta_1 \sim U(0, 1)$ and $\theta_0 \sim U(0, 1)$, only using the
PLUTO trial data.

```{cmdstan, output.var="refprior_mod", message = FALSE}
data {
  int<lower=0> ntrt;       // num. treated patients in historical data sets
  int<lower=0> nctrl;      // num. placebo patients in historical data sets
  int<lower=0> ytrt;       // num. responders in treated group for historical data sets
  int<lower=0> yctrl;      // num. responders in placebo group for historical data sets
}
parameters {
  real<lower=0,upper=1> theta1;     // response rate for treated
  real<lower=0,upper=1> theta0;     // response rate for placebo
}
model {
  ytrt ~ binomial(ntrt, theta1);
  yctrl ~ binomial(nctrl, theta0);
}
generated quantities {
  real risk_difference = theta1 - theta0;
  real risk_ratio = theta1 * inv(theta0);  // = theta1 / theta0
  real odds_ratio = (theta1 * inv(1-theta1)) * inv(theta0 * inv(1-theta0));
}
```


```{r refprior, message = FALSE, warning = FALSE}
refprior_smpl <- refprior_mod$sample(
  data = standata, chains = 4, parallel_chains = 4, iter_warmup = 2000
  , iter_sampling = 2500, refresh = 0
)
```


```{r plot}
df.refprior <- refprior_smpl$draws(variables = 'risk_difference', format = 'data.frame')
df.refprior$prior <- 'refprior'
df.pp  <- pp_smpl$draws(variables = 'risk_difference', format = 'data.frame')
df.pp$prior <- 'pp (a0 = 0.1)'
df.pp2 <- pp_smpl2$draws(variables = 'risk_difference', format = 'data.frame')
df.pp2$prior <- 'pp (a0 = 0.3)'
df.plot <- rbind(df.pp, df.pp2, df.refprior)
ggplot(
  df.plot, aes(x = risk_difference, fill = prior)
) + 
  geom_density(alpha = 0.5) + 
  scale_fill_tableau() + 
  ggtitle('Posterior densities')
```


